<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2026-02-17 Tue 14:28 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>acmicpc-17626</title>
<meta name="author" content="user0" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/css/tufte.css" />
<link rel="stylesheet" type="text/css" href="/css/ox-tufte.css" />
</head>
<body>
<article id="content" class="content">
<header>
<h1 class="title">acmicpc-17626</h1>
</header><section id="outline-container-org7f16d57" class="outline-2">
<h2 id="org7f16d57">Problem</h2>
<div class="outline-text-2" id="text-org7f16d57">
<p>
It was proven by Lagrange in 1770 that every natural number can be represented as the sum of four or fewer squares. Some numbers are represented in multiple ways. For example, 26 is the sum of 52 and 12; it can also be represented as 42 + 32 + 12. Expressing a number as the sum of four or fewer squares is historically a common problem posed to lightning calculators. It was reported in the early 1900s that a calculator produced a solution of 15663 = 1252 + 62 + 12 + 12 in 8 seconds. A more difficult problem took 56 seconds: 11339 = 1052 + 152 + 82 + 52.
</p>

<p>
Given a natural number n, write a program to express n as the sum of as few squares as possible.
</p>
</div>
</section>
<section id="outline-container-org99c01cb" class="outline-2">
<h2 id="org99c01cb">입력</h2>
<div class="outline-text-2" id="text-org99c01cb">
<p>
Your program is to read from standard input. The input consists of a single line containing a natural number n, where 1 ≤ n ≤ 50,000.
</p>
</div>
</section>
<section id="outline-container-orgd98eb26" class="outline-2">
<h2 id="orgd98eb26">출력</h2>
<div class="outline-text-2" id="text-orgd98eb26">
<p>
Your program is to write to standard output. Print exactly one line which contains the minimum number of squares whose sum is equal to n.
</p>
</div>
</section>
<section id="outline-container-org7925b9e" class="outline-2">
<h2 id="org7925b9e">Test Case</h2>
<div class="outline-text-2" id="text-org7925b9e">
<p>
예제 입력 1
</p>

<p>
25
</p>

<p>
예제 출력 1
</p>

<p>
1
</p>

<p>
예제 입력 2
</p>

<p>
26
</p>

<p>
예제 출력 2
</p>

<p>
2
</p>

<p>
예제 입력 3
</p>

<p>
11339
</p>

<p>
예제 출력 3
</p>

<p>
3
</p>

<p>
예제 입력 4
</p>

<p>
34567
</p>

<p>
예제 출력 4
</p>

<p>
4
</p>
</div>
</section>
<section id="outline-container-orgee35afe" class="outline-2">
<h2 id="orgee35afe">URL</h2>
<div class="outline-text-2" id="text-orgee35afe">
<p>
<a href="https://www.acmicpc.net/problem/17626">https://www.acmicpc.net/problem/17626</a>
</p>
</div>
</section>
<section id="outline-container-orgb948b55" class="outline-2">
<h2 id="orgb948b55">Remark</h2>
<div class="outline-text-2" id="text-orgb948b55">
</div>
<div id="outline-container-org0ce0959" class="outline-3">
<h3 id="org0ce0959">Naive solution</h3>
<div class="outline-text-3" id="text-org0ce0959">
<p>
First attempt, was a naive O(n<sup>2</sup>) solution, that looped over all possible combinations i and j and update dp. This algorithm is correct because of the "Time of Correctness" argument. Consider the following reasoning:
</p>

<p>
Any number K has an optimal decomposition. Since Lagrange's theorem proves the answer is ≤4, the optimal sum for K is always formed by adding a Square Number to some number smaller than k.
K=Smaller Number+Square
</p>

<p>
The "Time of Correctness" Argument: Let's define "Time" as the value of your outer loop iterator i. We want to prove that when you calculate dp[A + B], the values dp[A] and dp[B] are already fully optimized.
</p>

<p>
Level 1 (Squares): All perfect squares are initialized to 1 at the very start. They are correct at Time 0.
</p>

<p>
Level 2 (Sum of 2 Squares):
</p>

<p>
Take a number K=S1​+S2​ (where S are squares).
</p>

<p>
Your code updates dp[K] when the outer loop hits i = S<sub>1</sub> (inner j = S<sub>2</sub>) OR i = S<sub>2</sub> (inner j = S<sub>1</sub>).
</p>

<p>
This update happens at Time max(S1​,S2​).
</p>

<p>
At this time, dp[S<sub>1</sub>] and dp[S<sub>2</sub>] are definitely 1 (from step 1). So dp[K] correctly becomes 2.
</p>

<p>
Level 3 &amp; 4 (General Case):
</p>

<p>
Consider a number N whose optimal solution requires combining two parts A and B (e.g., N=A+B).
</p>

<p>
Assume A and B are already optimal (recursive hypothesis).
</p>

<p>
Since A and B are positive integers, A&lt;N and B&lt;N.
</p>

<p>
Crucially, the optimal dp[A] was computed at some time TA​≈max(components of A). Since the components are strictly smaller than A, dp[A] is ready before the loop reaches i = A.
</p>

<p>
Therefore, when your loop reaches i = A (and inner j = B), dp[A] is ready and dp[B] is ready.
</p>

<p>
The update dp[A+B] = dp[A] + dp[B] yields the correct result.
</p>

<p>
In Plain English: Your code tries to combine every number with every number. Since the optimal way to build a number is to combine a Square with a Smaller Number, your code inevitably covers this specific "Square + Number" case because it covers all cases.
</p>

<p>
Of course, this approach is suboptimal.
</p>
</div>
</div>
<div id="outline-container-org9639605" class="outline-3">
<h3 id="org9639605">sol1: O(Nroot(N)) Solution</h3>
<div class="outline-text-3" id="text-org9639605">
<p>
This approach takes advantage of the fact that any solution to K will be a sum of one square to an optimal solution of the smaller number.
</p>
</div>
</div>
<div id="outline-container-org7f6f53b" class="outline-3">
<h3 id="org7f6f53b">sol2: BFS Solution</h3>
<div class="outline-text-3" id="text-org7f6f53b">
<p>
This approach utilizes the fact that bfs always searches for shortest(most optimal, in our case) first. indeed this runs faster, since some unnecessary loops are stripped away, but dp is better for multiple queries. 
</p>
</div>
</div>
</section>
</article>
<footer id="postamble" class="status">
<p class="author">Author: user0</p>
<p class="date">Created: 2026-02-17 Tue 14:28</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</footer>
</body>
</html>
